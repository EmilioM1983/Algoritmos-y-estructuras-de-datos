<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso Express de Notación Big O</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="big-o.css">
</head>
<body>
    <header>
        <h1>Curso Express de Notación Big O</h1>
        <h3>Por Emilio Mayer</h3>
        
        
        
    </header>
    <div style="text-align: center; margin-top: 20px;">
        <a href="../../index.html" class="btn">Inicio</a>
    </div>
    <div class="course">
        <div class="card">
            <h2>¿Qué es la Notación Big O?</h2>
            <p>La notación Big O es una forma de describir el rendimiento o complejidad de un algoritmo. Nos ayuda a entender cómo el tiempo de ejecución o el uso de memoria de un algoritmo crece a medida que el tamaño de la entrada aumenta.</p>
            
            <p>En esencia, Big O describe el <strong>peor caso</strong> de escenario para un algoritmo, permitiéndonos comparar la eficiencia de diferentes enfoques para resolver un problema.</p>
            
            <h3>¿Por qué es importante?</h3>
            <ul>
                <li>Ayuda a elegir el algoritmo más eficiente para un problema</li>
                <li>Permite predecir el comportamiento con grandes volúmenes de datos</li>
                <li>Es fundamental en entrevistas técnicas</li>
                <li>Mejora la calidad del código y la experiencia del usuario</li>
            </ul>
        </div>
        
        <div class="card">
            <h2>Complejidades Más Comunes</h2>
            
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Notación</th>
                        <th>Nombre</th>
                        <th>Ejemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="complexity-badge badge-O1">O(1)</span></td>
                        <td>Constante</td>
                        <td>Acceso a un elemento de array</td>
                    </tr>
                    <tr>
                        <td><span class="complexity-badge badge-Ologn">O(log n)</span></td>
                        <td>Logarítmica</td>
                        <td>Búsqueda binaria</td>
                    </tr>
                    <tr>
                        <td><span class="complexity-badge badge-On">O(n)</span></td>
                        <td>Lineal</td>
                        <td>Recorrer un array</td>
                    </tr>
                    <tr>
                        <td><span class="complexity-badge badge-Onlogn">O(n log n)</span></td>
                        <td>Linealítmica</td>
                        <td>Algoritmos de ordenamiento eficientes</td>
                    </tr>
                    <tr>
                        <td><span class="complexity-badge badge-On2">O(n²)</span></td>
                        <td>Cuadrática</td>
                        <td>Algoritmos de ordenamiento simples</td>
                    </tr>
                    <tr>
                        <td><span class="complexity-badge badge-O2n">O(2ⁿ)</span></td>
                        <td>Exponencial</td>
                        <td>Problemas de fuerza bruta</td>
                    </tr>
                    <tr>
                        <td><span class="complexity-badge badge-Onfact">O(n!)</span></td>
                        <td>Factorial</td>
                        <td>Problemas del viajante</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="card full-width">
            <h2>Complejidad Big O Visualizada</h2>
            <p>La siguiente gráfica muestra cómo crecen las operaciones a medida que aumenta el número de elementos (n):</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #4CAF50;"></div>
                    <span>O(1) - Constante</span>
                </div>
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #8BC34A;"></div>
                    <span>O(log n) - Logarítmica</span>
                </div>
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #FFC107;"></div>
                    <span>O(n) - Lineal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #FF9800;"></div>
                    <span>O(n log n) - Linealítmica</span>
                </div>
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #F44336;"></div>
                    <span>O(n²) - Cuadrática</span>
                </div>
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #9C27B0;"></div>
                    <span>O(2ⁿ) - Exponencial</span>
                </div>
                <div class="legend-item">
                    <div class="legend-swatch" style="background-color: #673AB7;"></div>
                    <span>O(n!) - Factorial</span>
                </div>
            </div>
            
            <canvas id="bigOChart"></canvas>
        </div>
        
        <div class="card">
            <h2>Ejemplos en Java</h2>
            
            <h3>O(1) - Tiempo Constante</h3>
            <div class="code-example">
                <pre><span class="code-comment">// Acceso directo a un elemento de un array</span>
<span class="code-keyword">public int</span> <span class="code-function">getElement</span>(<span class="code-keyword">int</span>[] array, <span class="code-keyword">int</span> index) {
    <span class="code-keyword">return</span> array[index]; <span class="code-comment">// O(1)</span>
}</pre>
            </div>
            
            <h3>O(n) - Tiempo Lineal</h3>
            <div class="code-example">
                <pre><span class="code-comment">// Recorrer un array</span>
<span class="code-keyword">public int</span> <span class="code-function">findMax</span>(<span class="code-keyword">int</span>[] array) {
    <span class="code-keyword">int</span> max = array[0];
    <span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = 1; i < array.length; i++) { <span class="code-comment">// O(n)</span>
        <span class="code-keyword">if</span> (array[i] > max) {
            max = array[i];
        }
    }
    <span class="code-keyword">return</span> max;
}</pre>
            </div>
            
            <h3>O(log n) - Tiempo Logarítmico</h3>
            <div class="code-example">
                <pre><span class="code-comment">// Búsqueda binaria</span>
<span class="code-keyword">public int</span> <span class="code-function">binarySearch</span>(<span class="code-keyword">int</span>[] array, <span class="code-keyword">int</span> target) {
    <span class="code-keyword">int</span> left = 0;
    <span class="code-keyword">int</span> right = array.length - 1;
    
    <span class="code-keyword">while</span> (left <= right) { <span class="code-comment">// O(log n)</span>
        <span class="code-keyword">int</span> mid = left + (right - left) / 2;
        
        <span class="code-keyword">if</span> (array[mid] == target) {
            <span class="code-keyword">return</span> mid;
        } <span class="code-keyword">else if</span> (array[mid] < target) {
            left = mid + 1;
        } <span class="code-keyword">else</span> {
            right = mid - 1;
        }
    }
    <span class="code-keyword">return</span> -1;
}</pre>
            </div>
        </div>
        
        <div class="card">
            <h2>Consejos para Mejorar la Complejidad</h2>
            
            <h3>1. Evitar bucles anidados innecesarios</h3>
            <p>Los bucles anidados suelen llevar a complejidades O(n²) o peor. Considera usar estructuras de datos como HashMaps para reducir la complejidad.</p>
            
            <h3>2. Utilizar algoritmos de búsqueda eficientes</h3>
            <p>Para datos ordenados, la búsqueda binaria (O(log n)) es mucho más eficiente que la búsqueda lineal (O(n)).</p>
            
            <h3>3. Aprovechar estructuras de datos apropiadas</h3>
            <p>Elige la estructura de datos correcta para tu caso de uso:</p>
            <ul>
                <li><strong>HashMap:</strong> Para búsquedas rápidas O(1)</li>
                <li><strong>ArrayList:</strong> Para acceso rápido por índice O(1)</li>
                <li><strong>LinkedList:</strong> Para inserciones/eliminaciones frecuentes O(1)</li>
            </ul>
            
            <h3>4. Dividir y conquistar</h3>
            <p>Algoritmos como Merge Sort y Quick Sort utilizan el enfoque "divide y vencerás" para lograr O(n log n) en lugar de O(n²).</p>
            
            
                
        </div>
    </div>
    
    <footer>
        <p>Curso Express de Notación Big O - Comprende la complejidad algorítmica para escribir código más eficiente - Emilio Mayer</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="bigo.js">
    </script>
</body>
</html>